/*
 * euler - A collection of ProjectEuler libraries, tools, and solutions.
 * Copyright (C) 2013 Axel Rasmussen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <cstdint>
#include <stdexcept>

extern "C" {
#include <pthread.h>
#include <unistd.h>
}

#include "common/math/EMath.h"
#include "common/math/Math.hpp"
#include "common/util/Process.hpp"

// Utilize (# processors) + 1 threads.
#define THREADS
#define CONSUMER_THREAD_COUNT                                                  \
	((static_cast<std::size_t>(sysconf(_SC_NPROCESSORS_ONLN)) + 1))

/*
 * Pentagonal numbers are generated by the formula, P(n) = (n(3n - 1)) / 2. The
 * first ten pentagonal numbers are:
 *
 *     1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 *
 * It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). However, their
 * difference, 70 - 22 = 48, is not pentagonal.
 *
 * Find the pair of pentagonal numbers, P(j) and P(k), for which their sum and
 * difference is pentagonal and D = |P(k) - P(j)| is minimised; what is the
 * value of D?
 */

namespace
{
constexpr uint64_t EXPECTED_RESULT = 1912;

/*!
 * This structure provides a context for our worker threads, so they know what
 * to calculate.
 */
typedef struct ThreadContext
{
	uint64_t d;
	uint64_t result;
} ThreadContext;

/*!
 * This function attempts to solve the system of equations produced by setting
 * (x` + y`) and (x` - y`) equal to the factors a and b (where a > b; if b > a,
 * the factors are swapped), and places the result in the variables x and y if
 * the solutions are both a) integers and b) positive.
 *
 * This function, rather than using something like Gaussian elimination to solve
 * the system, instead just gives the values of x and y directly. This is
 * because the coefficients in the systems are always the same; it is only what
 * the system is equal to that changes, so we can get a closed form solution by
 * solving:
 *
 *     x` + y` = a
 *     x` - y` = b
 *
 * By solving this system of equations, we can see that x` = (a+b)/2 and
 * y` = (a-b)/2. We then set the values x` and y` represent equal to these
 * values, and solve for the respective variable to arrive at the final
 * solution.
 *
 * \param x The x-solution to the system.
 * \param y The y-solution to the system.
 * \param a The first factor.
 * \param b The second factor.
 * \return True if valid solutions exist, or false otherwise.
 */
bool solve(int64_t &x, int64_t &y, int64_t a, int64_t b)
{
	// Ensure a > b.

	if(a < b)
	{
		a ^= b;
		b ^= a;
		a ^= b;
	}

	// Solve for x` and y` using the closed-form solutions.

	int64_t xp = a + b, yp = a - b;

	if((xp & 1) || (yp & 1))
		return false;

	xp >>= 1;
	yp >>= 1;

	// Now, solve for x and y respectively.

	xp -= 1;
	yp += 1;

	// We only care about solutions where both x and y are positive
	// integers.

	if((xp >= 0) || (yp <= 0))
		return false;

	// Make sure we can divide by two.

	if((xp & 1) || (yp & 1))
		return false;

	xp >>= 1;
	yp >>= 1;

	// Make sure we can divide by three.

	if(((xp % 3) != 0) || ((yp % 3) != 0))
		return false;

	// Divide by three to get the final solution, and return success!

	x = -(xp / 3);
	y = yp / 3;

	return true;
}

void *consumer(void *c)
{
	ThreadContext *context = static_cast<ThreadContext *>(c);

	uint64_t d, pD;
	int64_t x, y, factor;

	while(true)
	{
		d = __sync_fetch_and_add(&context->d, 1);
		pD = EMath::getPentagonalNumberN(d);
		factor = static_cast<int64_t>(pD) * (-24);

		// Search for factors simply by trial division.

		for(int64_t a = 1;
		    static_cast<uint64_t>(a) <=
		    euler::math::isqrt(static_cast<uint64_t>(factor * -1));
		    ++a)
		{
			// See if we can stop.
			if((context->result - 1) <= d)
				return NULL;

			// See if this is a factor...
			if((factor % a) == 0)
			{
				// See if this factor produces a valid
				// solution...
				if(solve(x, y, a, factor / a))
				{
					// Teste if the solution produces a
					// pentagonal sum...
					if(EMath::isPentagonal(
					           EMath::getPentagonalNumberN(
					                   static_cast<
					                           uint64_t>(
					                           x)) +
					           EMath::getPentagonalNumberN(
					                   static_cast<
					                           uint64_t>(
					                           y))))
					{
						// We've found the answer! Halt.

						context->result = d;
						return NULL;
					}
				}
			}
		}
	}

	return NULL;
}

/*
 * A naieve approach would be to iterate over each pentagonal number, and then
 * see if there are any two other pentagonal numbers whose difference is the
 * given number.
 *
 * This requires, in order to be exhaustive, that one checks up to P(n) such
 * that 3*n + 1 > P(d), which (for this particular problem) equates to around
 * four billion loop iterations.
 *
 * This approach is to iterate over each pentagonal number, as before, but then
 * to express that pentagonal number as the difference of pentagonal numbers,
 * and to solve the resulting bivariate Diophantine quadratics.
 *
 * Consider the differnence P(d), which is equal to P(y) - P(x).
 * Thus:
 *
 *         P(d) = (y(3y - 1))/2 - (x(3x - 1))/2
 *        2P(d) = 3y^2 - y - 3x^2 + x
 *
 * Next, consider the arbitrary quadratic Diophantine equation in two variables,
 * giving the coefficients in our equation names:
 *
 *     Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0
 *
 * We multiply our entire equation by 4*A (= 12) in order to complete the square
 * with only integers remaining:
 *
 *     36y^2 - 12y - 36x^2 + 12x = 24P(d)
 *
 * Next, we complete the square on the first two terms by adding and
 * subtracting 1:
 *
 *     36y^2 - 12y + 1 - 36x^2 + 12x - 1 = 24P(d)
 *          (6y - 1)^2 - 36x^2 + 12x - 1 = 24P(d)
 *
 * Next, multiply by -1 so we can complete the square with the remaining two
 * terms:
 *
 *     -(6y - 1)^2 + 36x^2 - 12x + 1 = -24P(d)
 *         -(6y - 1)^2 + (-6x + 1)^2 = -24P(d)
 *
 * Next, let y` = 6y - 1 and let x` = -6x + 1, which allows us to rewrite the
 * equation as:
 *
 *            x`^2 - y`^2 = -24P(d)
 *     (x` + y`)(x` - y`) = -24P(d)
 *
 * At this point, we simply iterate over every pair of factors of -24P(d), and
 * we solve where (x` + y`) is equal to the larger factor, and (x` - y`) is
 * equal to the smaller factor. If any of these solutions are such that both
 * x and y are positive integers, then we have found the indices of the two
 * pentagonal numbers P(x) and P(y) such that P(y) - P(x) = P(d).
 *
 * Next, we can very rapidly test if P(x) + P(y) is itself pentagonal, giving us
 * our desired solution.
 */
euler::util::process::ProblemResult<uint64_t> problem()
{
#ifdef THREADS
	// Set initial thread context.

	ThreadContext context;
	context.d = 1;
	context.result = 0;

	// Spin up our thread.

	pthread_t *threads = new pthread_t[CONSUMER_THREAD_COUNT];

	for(std::size_t i = 0; i < CONSUMER_THREAD_COUNT; ++i)
	{
		int rc = pthread_create(&threads[i], NULL, consumer,
		                        static_cast<void *>(&context));
		if(rc)
		{
			throw std::runtime_error(
			        "Starting worker threads failed.");
		}
	}

	// Wait for all threads to finish up.

	for(std::size_t i = 0; i < CONSUMER_THREAD_COUNT; ++i)
		pthread_join(threads[i], NULL);

	delete[] threads;

	return {context.result, EXPECTED_RESULT};
#else
	uint64_t d, pD;
	int64_t x = 1, y = 1, factor;

	for(d = 1;; ++d)
	{
		pD = QMath::getPentagonalNumberN(d);
		factor = static_cast<int64_t>(pD) * (-24);

		// Search for factors simply by trial division.

		for(int64_t a = 1;
		    static_cast<uint64_t>(a) <=
		    euler::math::isqrt(static_cast<uint64_t>(factor * -1));
		    ++a)
		{
			// See if this is a factor...
			if((factor % a) == 0)
			{
				// See if this factor produces a valid
				// solution...
				if(solve(x, y, a, factor / a))
				{
					// Test if the solution produces a
					// pentagonal sum...
					if(QMath::isPentagonal(
					           QMath::getPentagonalNumberN(
					                   static_cast<
					                           uint64_t>(
					                           x)) +
					           QMath::getPentagonalNumberN(
					                   static_cast<
					                           uint64_t>(
					                           y))))
					{
						return {d, EXPECTED_RESULT};
					}
				}
			}
		}
	}

	return {0, EXPECTED_RESULT};
#endif
}
}

EULER_PROBLEM_ENTRYPOINT
